#!/usr/bin/python

import matplotlib.figure
import matplotlib.collections
import matplotlib.backends.backend_agg
import cPickle
import matplotlib.pyplot as plt
import sys
import re
import math

num_re = re.compile('(\d+)')

def numcmp(x, y):
   xn = num_re.match(x)
   if not xn: return cmp(x,y)
   
   yn = num_re.match(y)
   if not yn: return cmp(x,y)
  
   r = cmp(float(xn.group(0)), float(yn.group(0)))
   if r == 0:
      return cmp(x,y)
   else:
      return r

def overlap(joba, jobb):
   if jobb['start'] > joba['finish'] or joba['start'] > jobb['finish']:
      return False
   return True

def makeVnodes(nodes):
   # We may have multiple jobs at a time per node (e.g. SMP nodes), so 
   # treat those as multiple nodes.  Since we don't have an explicity thread id, 
   # just assign them arbitrarily in a non-overlapping way
   for nodename in nodes.keys():
      vnodes = []
      for job in nodes[nodename]:
         found = False
         for vnode in vnodes:
            conflict = False
            for j in vnode:
               if overlap(job, j):
                  #print "Conflict", job, "\nwith", j
                  conflict = True
                  break
            if not conflict:
               vnode.append(job)
               found = True
               break
         if not found:
            vnodes.append([job])
         #print "now", vnodes

      if len(vnodes) < 2:
         # It was serial, so no virtual nodes required
         continue

      del nodes[nodename]
      print "Replacing", nodename, "with", len(vnodes)
      for i in range(0, len(vnodes)):
         nodes[nodename + "." + str(i)] = vnodes[i]
         #print nodes.keys()

   return nodes
   
def plot(filename, pngfile):
   statsfile = open(filename, 'r')
   stats = cPickle.load(statsfile)
   statsfile.close()

   # Load all stats and keep track of min and max inputsizes along the way
   nodes = {}
   minsize = 2**31
   maxsize = 0
   for s in stats:
      s['start'] = s['timestamp'] - s['time']
      s['finish'] = s['timestamp']
      if not nodes.get(s['nodename']):
         nodes[s['nodename']] = []
      nodes[s['nodename']].append(s)

      minsize = min(minsize, s['inputsize'])
      maxsize = max(maxsize, s['inputsize'])

   nodes = makeVnodes(nodes)
         
   nodenames = nodes.keys()
   nodenames.sort(cmp=numcmp)

   # Build map of nodenames to y coordinates
   nodes2y = {}
   i = 0
   for n in nodenames:
      nodes2y[n] = i
      i += 1

   fig = matplotlib.figure.Figure()
   ax = fig.add_subplot(111)
   ax.set_autoscale_on(True)
  
   #l = matplotlib.lines.Line2D([1, 0.8e9], [2,2])
   #ax.add_line(l)
   #l = matplotlib.lines.Line2D([1269190522.252409, 1269190522.2774091], [14, 14])
   #ax.add_line(l)

   lines = []
   maxsize = math.log(maxsize)
   if not minsize:
      minsize = 0
   else:
      minsize = math.log(minsize)

   for node in nodes:
      y = nodes2y[node]
      for s in nodes[node]:

         finish = s['finish']
         start = s['start']

         # Size is a log-scal enumber between 0 and 1 where 0 is the minimum size seen in this run and 1 is the max size seen in this run
         insize = s['inputsize']
         if insize:
            insize = math.log(insize)
         else:
            insize = 0
         size = (insize-minsize)/(maxsize-minsize)
   
         # CPU is % of wallclock time in user or system CPU time
         if s['time'] == 0:
            cpu = 1
         else:
            cpu = (s['utime'] + s['stime']) / s['time']
   
         l = matplotlib.lines.Line2D([start, finish], [y,y], marker='|', alpha=0.25+cpu, lw=1 + 2*size)
         ax.add_line(l)
         lines.append([ (start,y), (finish,y) ])

   ax.autoscale_view()
   ax.set_yticks(range(0, i))
   ax.set_yticklabels(nodenames)
   ax.set_ylim(ymin=-2)

   canvas = matplotlib.backends.backend_agg.FigureCanvasAgg(fig)
   canvas.print_figure(pngfile, dpi=600)

if __name__ == '__main__':
   infile = ".fm.stats"
   pngfile = "fmstats.png"

   if len(sys.argv) > 1:
      infile = sys.argv[1]
   else:
      print >>sys.stderr, "Using %s as default input file" % infile

   if len(sys.argv) > 2:
      pngfile = sys.argv[2]
   else:
      print >>sys.stderr, "Using %s as default output file" % pngfile

   if len(sys.argv) > 3:
      print >>sys.stderr, "Usage: fmplot [<infile> [<outfile>]]"
      sys.exit(-1)

   plot(infile, pngfile)

